# Live BB Width Monitoring and Alerts - Integration with Existing 5-Min Candle Infrastructure

## 1. Overview

### 1.1 Core Requirement
Integrate BB width monitoring and audio alerts into the existing 5-minute candle close listener infrastructure that's already implemented in `GroupExecutionScheduler` and `GroupExecutionService`.

### 1.2 Primary Objectives
- **Leverage Existing Infrastructure**: Use existing 5-minute candle close events from `StockGroupService`
- **Extend GroupExecutionScheduler**: Add BB width monitoring to existing `OnFiveMinClose()` method
- **Real-time Monitoring**: Monitor BB width for stocks in active groups during market hours
- **Audio Alerts**: Trigger sound alerts with symbol name when thresholds are met
- **Minimal Disruption**: Keep existing group execution logic intact

### 1.3 Key Metrics
- **BB Width**: `(Upper_Bollinger_Band - Lower_Bollinger_Band) / Middle_Bollinger_Band`
- **Squeeze Threshold**: When BB width reaches 10th percentile of historical values
- **Expansion Threshold**: When BB width reaches 90th percentile of historical values
- **Alert Triggers**: Audio notification with symbol name when thresholds are crossed

## 2. Existing Infrastructure Analysis

### 2.1 Current 5-Minute Candle System
The system already has a complete 5-minute candle infrastructure:

#### 2.1.1 StockGroupService
```go
type FiveMinCloseListener func(start, end time.Time)

// Register listener for 5-min candle close events
func (s *StockGroupService) RegisterFiveMinCloseListener(listener FiveMinCloseListener)

// Fire 5-min close event to all registered listeners
func (s *StockGroupService) Fire5mCloseEvent(start, end time.Time)
```

#### 2.1.2 GroupExecutionScheduler
```go
// Already registered as listener in NewGroupExecutionScheduler()
stockGroupService.RegisterFiveMinCloseListener(s.OnFiveMinClose)

// Receives 5-min candle close events
func (s *GroupExecutionScheduler) OnFiveMinClose(start, end time.Time) {
    // Currently triggers group execution for specific entry types 
    // We will extend this to also trigger BB width monitoring
    // add new entry type as BB_RANGE which tells the system that when lowest min bb_width is achieved, entry can be placed
}
```

#### 2.1.3 GroupExecutionService
```go
// Already processes stocks with 5-min candles
func (s *GroupExecutionService) ExecuteDetailedGroup(ctx context.Context, group dto.StockGroupResponse, start, end time.Time) error {
    // Gets 5-min candles for each stock
    candles, err := s.CandleAggregationService.Get5MinCandles(ctx, stockRef.InstrumentKey, start, end)
    // We can leverage this same candle data for BB width calculation
}
```

### 2.2 Existing Technical Indicator Infrastructure
- **TechnicalIndicatorService**: Already calculates BB width
- **CandleAggregationService**: Already provides 5-minute candles
- **StockGroupService**: Already manages active groups and stocks

## 3. Integration Strategy

### 3.1 High-Level Integration Approach
Instead of creating new infrastructure, we will:

1. **Extend GroupExecutionScheduler**: Add BB width monitoring service as dependency
2. **Modify OnFiveMinClose()**: Trigger BB width monitoring for all active groups
3. **Create BBWidthMonitorService**: Process stocks and calculate thresholds
4. **Create AlertService**: Handle audio alerts
5. **Wire up in app.go**: Add new services to dependency injection

### 3.2 Integration Points

#### 3.2.1 Extend GroupExecutionScheduler
```go
type GroupExecutionScheduler struct {
    groupExecutionService *GroupExecutionService
    stockGroupService     *StockGroupService
    universeService       *StockUniverseService
    // NEW: Add BB width monitoring service
    bbWidthMonitorService *BBWidthMonitorService
}

func (s *GroupExecutionScheduler) OnFiveMinClose(start, end time.Time) {
    // EXISTING: Group execution logic
    candleHHMM := start.Format("15:04")
    for entryType, triggerTime := range EntryTypeTriggerTimes {
        if candleHHMM == triggerTime {
            s.TriggerGroupExecution(context.Background(), entryType, start, end)
        }
    }
    
    // NEW: BB width monitoring for all active groups
    s.bbWidthMonitorService.MonitorAllActiveGroups(context.Background(), start, end)
}
```

#### 3.2.2 BB Width Monitor Service
```go
type BBWidthMonitorService struct {
    stockGroupService     *StockGroupService
    technicalIndicatorSvc *TechnicalIndicatorService
    alertService          *AlertService
    config                *config.Config
}

func (s *BBWidthMonitorService) MonitorAllActiveGroups(ctx context.Context, start, end time.Time) error {
    // Get all active groups
    groups, err := s.stockGroupService.GetGroupsByEntryType(ctx, "", s.universeService)
    if err != nil {
        return err
    }
    
    // Monitor each group's stocks
    for _, group := range groups {
        s.monitorGroupStocks(ctx, group, start, end)
    }
    return nil
}
```

## 4. Implementation Phases

### 4.1 Phase 1: Extend GroupExecutionScheduler (1-2 files)
**Goal**: Add BB width monitoring to existing 5-minute candle infrastructure
And add new entry_type as BB_RANGE into the go backend where ever required. 

**Files to Modify**:
- `internal/service/group_execution_scheduler.go` (add BB width monitoring)
- `internal/service/bb_width_monitor_service.go` (new service)

**Changes**:
1. Add `BBWidthMonitorService` dependency to `GroupExecutionScheduler`
2. Extend `OnFiveMinClose()` to trigger BB width monitoring
3. Create basic `BBWidthMonitorService` with group monitoring logic

**Deliverables**:
- Extended scheduler that monitors BB width for all active groups
- Basic BB width monitoring service structure
- Integration with existing 5-minute candle events

### 4.2 Phase 2: BB Width Calculation and Threshold Detection (1-2 files)
**Goal**: Implement BB width calculation and threshold detection logic

**Files to Modify**:
- `internal/service/bb_width_monitor_service.go` (threshold logic)
- `internal/service/alert_service.go` (new alert service)

**Changes**:
1. Implement BB width calculation using existing `TechnicalIndicatorService`
2. Add historical BB width analysis for threshold calculation
3. Implement squeeze/expansion detection logic
    3.1 Squeeze if in past 3-5 5min candles, the bb width is contracting and 3rd or 5th candle is between lowest_min_bb_width_range, then trigger alert
    3.2 lowest_min_bb_width_range means, [-0.10%, +0.10%] of the lowest_min_bb_width. 
    3.3 basically i want to know atleast 3-5 candles prior that my optimal trading range which is lowest_min_bb_width_range is coming in next 15-30mins. 
4. Create basic alert service structure

**Deliverables**:
- BB width and lowest_min_bb_width_range calculation for 5-minute candles
- Historical percentile-based threshold and lowest_min_bb_width_range detection
- checking if the current candle is in lowest_min_bb_width_range range. 
- Alert triggering mechanism
- Basic alert service

### 4.3 Phase 3: Audio Alert System and Integration (1-2 files)
**Goal**: Implement audio alerts and wire up all services

**Files to Modify**:
- `internal/service/alert_service.go` (audio implementation)
- `cmd/trading/app/app.go` (wire up services)

**Changes**:
1. Implement audio alert playback with symbol pronunciation
2. Add alert cooldown and rate limiting
3. Wire up all services in app.go
4. Add configuration for BB width monitoring

**Deliverables**:
- Complete audio alert system
- Full service integration
- Configuration management
- End-to-end BB width monitoring and alerting

## 5. Technical Implementation Details

### 5.1 BB Width Calculation Integration
```go
func (s *BBWidthMonitorService) calculateBBWidth(ctx context.Context, instrumentKey string, start, end time.Time) (float64, error) {
    // Use existing TechnicalIndicatorService to get BB width
    bbWidthValues, err := s.technicalIndicatorSvc.CalculateBBWidthForRange(
        ctx, instrumentKey, 20, 2.0, "5minute", start, end
    )
    if err != nil || len(bbWidthValues) == 0 {
        return 0, err
    }
    
    // Return the latest BB width value
    return bbWidthValues[len(bbWidthValues)-1].Value, nil
}
```

### 5.2 Historical Threshold Calculation
```go
func (s *BBWidthMonitorService) getHistoricalThresholds(ctx context.Context, instrumentKey string) (squeezeThreshold, expansionThreshold float64, err error) {
    // Get historical BB width data (last 20 days)
    end := time.Now()
    start := end.AddDate(0, 0, -20)
    
    bbWidthValues, err := s.technicalIndicatorSvc.CalculateBBWidthForRange(
        ctx, instrumentKey, 20, 2.0, "5minute", start, end
    )
    if err != nil {
        return 0, 0, err
    }
    
    // Calculate percentiles
    squeezeThreshold = calculatePercentile(bbWidthValues, 10)  // 10th percentile
    expansionThreshold = calculatePercentile(bbWidthValues, 90) // 90th percentile
    
    return squeezeThreshold, expansionThreshold, nil
}
```

### 5.3 Alert Triggering Logic
```go
func (s *BBWidthMonitorService) checkAndTriggerAlert(ctx context.Context, stock *StockMonitor, bbWidth float64) error {
    squeezeThreshold, expansionThreshold, err := s.getHistoricalThresholds(ctx, stock.InstrumentKey)
    if err != nil {
        return err
    }
    
    var alertType string
    if bbWidth <= squeezeThreshold {
        alertType = "squeeze"
    } else if bbWidth >= expansionThreshold {
        alertType = "expansion"
    } else {
        return nil // No alert needed
    }
    
    // Check cooldown and rate limits
    if !s.shouldAlert(stock, alertType) {
        return nil
    }
    
    // Trigger audio alert
    alert := AlertEvent{
        Symbol:    stock.Symbol,
        BBWidth:   bbWidth,
        Threshold: alertType,
        Timestamp: time.Now(),
        GroupID:   stock.GroupID,
    }
    
    return s.alertService.PlayAlert(alert)
}
```

## 6. Configuration Integration

### 6.1 Config Structure
```yaml
# Add to existing application.dev.yaml
bb_width_monitoring:
  enabled: true
  alert:
    enabled: true
    volume: 0.8
    sound_path: "/assets/alert.wav"
    cooldown_seconds: 300  # 5 minutes
    max_alerts_per_hour: 10
  thresholds:
    squeeze_percentile: 10    # 10th percentile for squeeze
    expansion_percentile: 90  # 90th percentile for expansion
    lowest_min_bb_width_range_threshold: 0.10 # 0.10% of the given lowest_min_bb_width
    lookback_days: 20         # Historical data for percentile calculation
```

### 6.2 Service Wiring in app.go
```go
// In cmd/trading/app/app.go - NewApp() function
alertService := service.NewAlertService(cfg.BBWidthMonitoring.Alert)
bbWidthMonitorService := service.NewBBWidthMonitorService(
    stockGroupService,
    technicalIndicatorService,
    alertService,
    cfg,
)

// Update GroupExecutionScheduler with BB width monitoring
groupExecutionScheduler := service.NewGroupExecutionScheduler(
    groupExecutionService,
    stockGroupService,
    stockUniverseService,
    bbWidthMonitorService, // NEW: Add BB width monitoring
)
```

## 7. Benefits of This Integration Approach

### 7.1 Leverages Existing Infrastructure
- **No new event system**: Uses existing 5-minute candle close events
- **No new scheduling**: Uses existing `GroupExecutionScheduler`
- **No new data flow**: Uses existing candle aggregation and technical indicators
- **Minimal code changes**: Extends rather than replaces existing functionality

### 7.2 Maintains System Integrity
- **Existing group execution**: Unchanged and continues to work
- **Existing 5-minute events**: Continue to fire as before
- **Existing services**: All continue to function normally
- **Backward compatibility**: No breaking changes

### 7.3 Efficient Resource Usage
- **Shared candle data**: BB width calculation uses same 5-minute candles as group execution
- **Shared technical indicators**: Uses existing `TechnicalIndicatorService`
- **Shared group management**: Uses existing `StockGroupService`
- **Minimal overhead**: Only adds BB width calculation and alert logic

## 8. Testing Strategy

### 8.1 Unit Tests
- **BB width calculation accuracy**
- **Threshold detection logic**
- **Alert cooldown and rate limiting**
- **Integration with existing services**

### 8.2 Integration Tests
- **End-to-end 5-minute candle flow**
- **BB width monitoring with group execution**
- **Audio alert system**
- **Configuration management**

### 8.3 Performance Tests
- **BB width calculation performance**
- **Alert system responsiveness**
- **Memory usage with monitoring**
- **Concurrent group monitoring**

## 9. Deployment Considerations

### 9.1 Gradual Rollout
- **Phase 1**: Deploy BB width monitoring without alerts
- **Phase 2**: Enable alerts with low volume
- **Phase 3**: Full alert system with monitoring

### 9.2 Monitoring and Observability
- **BB width calculation metrics**
- **Alert trigger rates**
- **System performance impact**
- **Error rates and recovery**

### 9.3 Configuration Management
- **Environment-specific thresholds**
- **Dynamic alert settings**
- **Performance tuning parameters**
- **Feature flags for gradual rollout**

## 10. Conclusion

This integration approach maximizes the use of existing infrastructure while adding BB width monitoring and alerting capabilities. By extending the existing 5-minute candle close listener system, we:

1. **Minimize code changes** and risk
2. **Leverage proven infrastructure** that's already working
3. **Maintain system integrity** and backward compatibility
4. **Ensure efficient resource usage** through shared components
5. **Enable rapid deployment** with minimal disruption

The phased implementation ensures incremental delivery of functionality while maintaining system stability and performance. The modular design allows for future enhancements and integrations as the system evolves.

**Key Success Factors:**
- **Reliable integration** with existing 5-minute candle infrastructure
- **Efficient BB width calculation** using existing technical indicators
- **High-quality audio alerts** with clear symbol pronunciation
- **Robust error handling** and graceful degradation
- **Comprehensive testing** across all integration points

This approach provides traders with timely BB width alerts while maintaining the reliability and performance of the existing trading system.