"""
Models and types for Morning Range strategy signals.

This module contains the data models and types used for signal generation
in the Morning Range strategy.
"""

from enum import Enum
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Dict, Any, List
import logging

logger = logging.getLogger(__name__)

class SignalType(Enum):
    """
    Types of signals that can be generated by the strategy.
    
    IMMEDIATE_BREAKOUT: Price breaks above/below MR level (original 5MR strategy)
    BREAKOUT_CONFIRMATION: Price moves beyond breakout threshold
    RETEST_ENTRY: Price retests MR level after confirmed breakout
    TWO_THIRTY_ENTRY: Entry at 2:30 PM based on specific conditions
    """
    IMMEDIATE_BREAKOUT = "immediate_breakout"
    BREAKOUT_CONFIRMATION = "breakout_confirmation"
    RETEST_ENTRY = "retest_entry"
    TWO_THIRTY_ENTRY = "two_thirty_entry"

class SignalDirection(Enum):
    """
    Direction of the signal (long or short).
    """
    LONG = "LONG"
    SHORT = "SHORT"

@dataclass
class Signal:
    """
    Represents a trading signal generated by the strategy.
    
    Attributes:
        type: Type of signal (from SignalType enum)
        direction: Direction of signal (LONG or SHORT)
        timestamp: Time when signal was generated
        price: Price level at which signal was generated
        mr_values: Morning Range values at time of signal
        metadata: Additional signal-specific information
    """
    type: SignalType
    direction: SignalDirection
    timestamp: datetime
    price: float
    mr_values: Dict[str, Any]
    metadata: Optional[Dict[str, Any]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal to dictionary for logging/debugging."""
        return {
            'type': self.type.value,
            'direction': self.direction.value,
            'timestamp': self.timestamp.isoformat(),
            'price': self.price,
            'mr_values': self.mr_values,
            'metadata': self.metadata or {}
        }
    
    def __str__(self) -> str:
        """String representation of the signal."""
        return (f"Signal(type={self.type.value}, direction={self.direction.value}, "
                f"timestamp={self.timestamp}, price={self.price})")

@dataclass
class SignalGroup:
    """
    Represents a group of related signals (e.g., breakout and retest).
    
    Attributes:
        signals: List of signals in the group
        start_time: Time when the first signal was generated
        end_time: Time when the last signal was generated
        status: Current status of the signal group
    """
    signals: List[Signal]
    start_time: datetime
    end_time: datetime
    status: str  # 'active', 'completed', 'invalidated'
    
    def add_signal(self, signal: Signal) -> None:
        """Add a new signal to the group."""
        self.signals.append(signal)
        self.end_time = signal.timestamp
        logger.debug(f"Added signal to group: {signal}")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert signal group to dictionary for logging/debugging."""
        return {
            'signals': [s.to_dict() for s in self.signals],
            'start_time': self.start_time.isoformat(),
            'end_time': self.end_time.isoformat(),
            'status': self.status
        }
    
    def __str__(self) -> str:
        """String representation of the signal group."""
        return (f"SignalGroup(signals={len(self.signals)}, "
                f"start_time={self.start_time}, end_time={self.end_time}, "
                f"status={self.status})") 